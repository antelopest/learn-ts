# Типы массивов: `string[]`, `Array<string>`

## Синтаксис `string[]`

Это наиболее распространенный и лаконичный способ указать, что переменная является массивом строк.

```ts
let fruits: string[] = ['apple', 'banana', 'orange'];
```

### Особенности:

* `string[]` означает, что массив может содержать только элементы типа string.
* Это синтаксический сахар, который делает код более читаемым.
* Подходит для большинства случаев, когда нужно просто указать тип элементов массива.

### Пример использования:

```ts
let names: string[] = ['John', 'Mary', 'Peter'];

names.push("Charlie");
names.push(42); // Error: Type 'number' is not assignable to type 'string'.
```

## Синтаксис `Array<string>`

Это альтернативный способ типизации массива с использованием обобщенного типа `Array`.

```ts
let fruits: Array<string> = ["apple", "banana", "orange"];
```

### Особенности:

* `Array<T>` — это обобщенный (`generic`) тип, где `T` — тип элементов массива.
* Эквивалентен `string[]`, но более многословен.
* Полезен в ситуациях, когда используются более сложные обобщенные типы или требуется единообразие с другими обобщёнными
  конструкциями.

### Пример использования:

```ts
let names: Array<string> = ["John", "Mary", "Peter"];

names.push("Charlie");
names.push(42); // Error: Type 'number' is not assignable to type 'string'.
```

## Сравнение `string[]` и `Array<string>`:

* Синтаксис
    * `string[]` короче и чаще используется в повседневной разработке.
    * `Array<string>` более многословен, но может быть полезен в контексте сложных обобщенных типов.
* Читаемость
    * `string[]` считается более читаемым и является стандартом в большинстве кодовых баз.
    * `Array<string>` чаще встречается в документации или коде, где используются другие обобщенные типы.
* Функциональность
    * Оба способа эквивалентны в плане проверки типов и поведения.
    * Нет разницы в производительности или возможностях.
* Когда использовать
    * Используйте string[] для простоты и читаемости.
    * Используйте Array<string>, если вы работаете с обобщенными типами или хотите подчеркнуть, что это массив в
      контексте сложной типизации.

## Дополнительные аспекты типизации массивов

### Только для чтения (Readonly)

TypeScript предоставляет возможность сделать массив неизменяемым с помощью readonly или ReadonlyArray.

```ts
let readonlyArray: ReadonlyArray<string> = ["hello", "world"];
readOnlyArray.push("orange"); // Ошибка: Property 'push' does not exist on type 'readonly string[]'

let readOnlyFruits2: ReadonlyArray<string> = ["apple", "banana"];
readOnlyFruits2.push("orange"); // Ошибка: Property 'push' does not exist on type 'ReadonlyArray<string>'
```

### Типизация смешанных массивов

Если массив может содержать элементы разных типов, можно использовать union-типы:

```ts
let mixed: (string | number)[] = ["hello", 10];
let mixed2: Array<string | number> = ["apple", 42, "banana"];
```

### Типизация пустых массивов

Если массив изначально пустой, TypeScript может потребовать явного указания типа, иначе он выведет any[].

```ts
let empty: string[] = [];
let empty2: Array<string> = [];
let problematic = []; // Type any[]
```

## Практические примеры

### Работа с методами массива:

TypeScript корректно проверяет типы при использовании методов массива, таких как `map`, `filter` и тд.

```ts
let names: string[] = ["Alice", "Bob", "Charlie"];
let upperCaseNames: string[] = names.map(name => name.toUpperCase());
```

### Обобщенные функции с массивами:

Используйте `Array<T>` удобно в обобщённых функциях:

```ts
function getFirst<T>(arr: Array<T>): T | undefined {
    return arr[0];
}

let firstName = getFirst<string>(["John", "Mary", "Peter"]);
```

## Рекомендации

* Используйте `string[]` для простых случаев, когда массив содержит строки и не требуется сложная логика.
* Используйте `Array<string>` в обобщенных функциях или сложных типах, чтобы сохранить консистентность.
* Избегайте `any[]`, всегда указывайте тип элементов массива для строгой типизации.
* Рассмотрите `readonly` для защиты массивов от изменений, если это соответствует логике программы.