# Типы объектов: `{ key: value }`

В TypeScript типизация объектов — это важная часть работы с языком, так как она позволяет строго определять структуру
данных, с которыми работает программа.

Тип объектов обычно описывается с помощью синтаксиса {key: value}, где key — это имя свойства, а value — его тип.

## Базовый синтаксис

Объекты в TypeScript типизируются с помощью фигурных скобок, где указываются ключи (свойства) и их типы.

```ts
let user: { name: string; age: number } = {
    name: "Alice",
    age: 25,
}
```

### Особенности

* Каждое свойство объекта должно соответствовать указанному типу.
* Если попытаться добавить лишние свойства или пропустить обязательные, TypeScript выдаст ошибку.

```ts
let user: { name: string; age: number } = {
    name: "Alice",
    age: 25,
    email: "alice@example.com", // Error: Object literal may only specify known properties.
}

let user2: { name: string, age: number } = {
    name: "Bob", // Error: Property 'age' is missing
}
```

## Опциональные свойства

Если свойство объекта может быть необязательным, используется модификатор `?`.

```ts
let user: { name: string; age?: number } = {
    name: "Alice"
    // age можно не указывать
}
```

### Особенности

* Опциональные свойства могут быть либо указаны (с соответствующим типом), либо отсутствовать (`undefined`).
* Это полезно для объектов, где не все поля обязательны.

```ts
let user: { name: string; age?: number } = {
    name: "Alice",
    age: undefined, // OK
}
```

## Только для чтения (Readonly)

Свойства объекта можно сделать неизменяемыми с помощью модификатора `readonly`.

```ts
let user: {
    readonly name: string;
    age: number
} = {
    name: "Alice",
    age: 25,
}

user.age = 26; // OK
user.name = "Bob"; // Error: Cannot assign to 'name' because it is a read-only property
```

### Особенности

* `readonly` предотвращает изменение свойства после его инициализации.
* Это не делает объект полностью неизменяемым, а только указанные свойства.

## Индексные сигнатуры

Если объекты может содержать произвольное количество свойств с одинаковым типом, используется индексная сигнатура.

```ts
let dictionary: { [key: string]: number } = {
    apple: 5,
    banana: 10
};

dictionary["orange"] = 15; // OK
dictionary["grape"] = "20"; // Error: Type "String" is not assignable to type "number"
```

### Особенности:

* Индексная сигнатура задается в формате [key: тип_ключа]: тип_значения.
* Обычно используется `string` или `number` для ключей.
* Полезно для объектов, структура которых заранее неизвестна (например, словари или мапы).

## Объединение типов (Union Types) в объектах

Свойства объекта могут иметь несколько возможных типов, используя union-типы.

```ts
let user: { name: string; id: string | number } = {
    name: "Alice",
    id: 123, // OK
}

user.id = "user-123"; // OK
user.id = true; // Error: Type 'boolean' is not assignable to type 'string | number'
```

## Типизация объектов с помощью интерфейсов

Для более сложных или повторно используемых объектов рекомендуется использовать интерфейсы (`interface`).

```ts
interface User {
    name: string;
    age?: number;
    readonly id: string;
}

let user: User = {
    name: "Alice",
    id: "user-123",
}

user.age = 25; // OK
user.id = "new-id"; // Error: Cannot assign to "id" because it is a read-only property
```

### Особенности:

* Интерфейсы позволяют переиспользовать типы и расширять их.
* Более структурированный подход, чем прямое использование `{ key: value }`.

## Тип `record`

TypeScript предоставляет утилиту `Record` для создания объектов с индексной сигнатурой, где ключи и значения строго
типизированы.

```ts
let scores: Record<string, number> = {
    Alice: 90,
    Bob: 85,
}

scores["Charlie"] = 95; // OK
scores["Dave"] = "100"; // Error: Type 'string' is not assignable to type 'number'
```

### Особенности

* `Record<K, T>` создает объект, где ключи имеют тип `K`, а значения - тип `T`.
* Альтернатива индексной сигнатуре, более строгая и читаемая.

## Типизация методов в объектах

Объекты могут содержать методы, которые также можно типизировать.

```ts
let calculator: {
    add: (a: number, b: number) => number;
    subtract?: (a: number, b: number) => number;
} = {
    add: (a, b) => a + b,
};

console.log(calculator.add(5, 3)); // 8
```

## Практические примеры

### Типизация конфигурационного объекта:

```ts
let config: { apiUrl: string; timeout?: number } = {
    apiUrl: 'https://api.example.com'
};
```

### Объект с динамическими ключами:

```ts
let settings: { [key: string]: string | number } = {
    theme: 'light',
    fontSize: 14
};
```

### Использование интерфейса для сложного объекта:

```ts
interface Employee {
    id: string;
    name: string;
    age: number;
    role: "developer" | "manager" | "designer";
    skills?: string[];
}

let employee: Employee = {
    id: "emp-001",
    name: "Alice",
    role: "developer",
    skills: ["TypeScript", "React"]
}
```

## Рекомендации

* Используйте `{ key: value }` для простых объектов, если структура не повторяется.
* Применяйте интерфейсы для сложных или повторно используемых объектов.
* Используйте `readonly` дл защиты свойств от изменений.
* Применяйте индексные сигнатуры или `Record` для объектов с динамическими ключами.
* Избегайте `any`, чтобы сохранить строгую типизацию.
* Проверяйте опциональные свойства с помощью `?`, если они могут отсутствовать.