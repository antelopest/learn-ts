# Тип `any`, `unknown`, `never`

В TypeScript, помимо примитивных типов (string, number, null, undefined, boolean, bigint, symbol), существуют
специальные типы, которые играют важную роль в системе типов: any, unknown, never.
Эти типы используются в специфических сценариях, когда требуется гибкость или строгая типизация.

## any

### Описание:

Тип `any` — это "универсальный" тип, который позволяет присваивать переменной значение любого типа без проверки типов.

Это отключает проверку типов TypeScript, делая код менее безопасным.

### Использование:

Используется, когда тип данных неизвестен или когда требуется временно обойти строгую типизацию (например, при работе с
динамическими данными, такими как JSON из API).

### Пример:

```ts
let value: any = 42;
value = "Hello"; // OK, нет ошибки
value = true; // OK
console.log(value.toUpperCase()); // Работает, если value — строка, иначе ошибка в runtime
```

### Особенности:

Отключает проверку типов, что может привести к ошибкам во время выполнения.

Следует избегать использования any, если есть возможность указать более конкретный тип.

Полезно для миграции JavaScript-кода в TypeScript или работы с библиотеками без типов.

### Проблемы:

```ts
let data: any = "text";
data.push(42); // Ошибка в runtime, так как строка не имеет метода push
```

Решение:

Используйте более конкретные типы или `unknown` для большей безопасности.

## unknown

### Описание:

Тип unknown — это безопасная альтернатива any. Он также позволяет присваивать любое значение, но требует явной проверки
типа перед использованием.

### Использование:

Подходит для случаев, когда тип данных неизвестен (например, результат API), но вы хотите обеспечить безопасность типов.

### Пример:

```ts
let value: unknown = JSON.parse('{"name": "Alice"}');
// value.name; // Ошибка: Object is of type 'unknown'
if (typeof value === "object" && value !== null && "name" in value) {
    console.log(value.name); // OK, после проверки типа
}
```

### Особенности:

Требует проверки типа (например, с помощью typeof, instanceof, или кастомных проверок).

Более безопасен, чем any, так как предотвращает случайное использование неправильных методов или свойств.

Часто используется с union types для уточнения типа:

```ts
let input: unknown;
if (typeof input === "string") {
    console.log(input.toUpperCase()); // OK
}
```

## never

### Описание:

Тип `never` обозначает значение, которое никогда не возникает.

Используется для функций, которые никогда не возвращают значение, или для ситуаций, где тип не может существовать.

### Использование:

Для функций, которые всегда выбрасывают исключение или бесконечно выполняются.

Для исчерпывающего анализа в `switch` или условных конструкциях.

### Пример:

```ts
function throwError(message: string): never {
    throw new Error(message);
}

function infiniteLoop(): never {
    while (true) {
    }
}

// Исчерпывающий анализ в switch
type Shape = "circle" | "square";

function getArea(shape: Shape) {
    switch (shape) {
        case "circle":
            return Math.PI * 2;
        case "square":
            return 4;
        default:
            const _exhaustiveCheck: never = shape; // Ошибка, если добавится новый тип в Shape
            throw new Error("Unknown shape");
    }
}


```

### Особенности:

`never` не совместим ни с одним типом, кроме самого себя.

Полезен для обнаружения ошибок в логике программы на этапе компиляции.

Пример ошибки:

```ts
let value: never;

value = 42; // Error: Type 'number' is not assignable to type 'never'
```

## Советы

Избегайте `any`: Используйте `unknown` или конкретные типы для большей безопасности.

Проверки для `unknown`:

```ts
function processData(data: unknown) {
    if (typeof data === "string") {
        return data.toUpperCase();
    } else if (typeof data === "number") {
        return data * 2;
    } else {
        throw new Error("Invalid data type");
    }
}
```

Используйте `never` для проверки полноты:

* В switch или if добавляйте never, чтобы TypeScript сигнализировал о пропущенных случаях.

Настройка `tsconfig.json`:

* Включите `"strict": true`, чтобы `unknown` использовался вместо `any` в некоторых контекстах (например, для catch в
  try/catch).

## Пример комбинированного использования

```ts
function processValue(input: unknown): string {
    if (typeof input === 'string') {
        return input.toUpperCase();
    } else if (typeof input === 'number') {
        return `Number: ${input}`;
    } else {
        const neverValue: never = input; // Error
        throw new Error("Unsupported type");
    }
}

console.log(processValue('hello')); // HELLO
console.log(processValue(123)); // Number: 123
console.log(processValue(true)); // Error: Unsupported type
```

## Заключение

* **any:** Следует использовать с осторожностью, только если тип действительно неизвестен и нет возможности уточнить.
* **unknown:** Предпочтительный выбор для неизвестных типов, так как требует проверки.
* **never:** Полезен для функций без возврата и для обеспечения полноты анализа типов.